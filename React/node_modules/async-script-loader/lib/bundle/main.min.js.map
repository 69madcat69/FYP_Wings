{"version":3,"sources":["../../node_modules/uuid/lib/bytesToUuid.js","../../node_modules/uuid/lib/rng-browser.js","../../node_modules/uuid/v4.js","../../src/main.js"],"names":["getRandomValues","crypto","bind","msCrypto","rnds8","Uint8Array","module","exports","rnds","Array","r","i","Math","random","byteToHex","toString","substr","bytesToUuid_1","buf","offset","bth","v4_1","options","rng","ii","bytesToUuid","LOADED","ERROR","scriptMap","Map","load","script","reload","arguments","length","undefined","src","id","uuid","key","has","item","get","promise","error","Promise","resolve","callbackName","replace","tag","window","document","createElement","type","async","reject","handleResult","state","evt","callback","instance","loaded","set","onerror","onreadystatechange","readyState","match","onload","addEventListener","body","appendChild","initialState"],"mappings":"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","file":"main.min.js","sourcesContent":["/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","import uuid from 'uuid/v4'\n\nconst LOADED = 'loaded'\nconst ERROR = 'error'\n\nconst scriptMap = new Map()\n\n/**\n * Clean up the callback\n *\n * @param {string} callback The callback function name\n *\n * @return {void}\n */\nconst cleanup = callback => {\n  if (!window[callback] || typeof window[callback] !== 'function') {\n    return\n  }\n\n  window[callback] = null\n}\n\n/**\n * Load a script asynchronously\n *\n * @param {string} script The script to load\n * @param {bool} reload If the script should be loaded even if it was loaded before\n *\n * @return {Promise}\n */\nexport const load = (script, reload = false) => {\n  let src = script\n  const id = uuid()\n  const key = reload ? `${script}${id}` : script\n  if (scriptMap.has(key)) {\n    const item = scriptMap.get(key)\n    if (item.promise) {\n      return item.promise\n    }\n\n    if (item.error) {\n      return Promise.resolve(item.error)\n    }\n\n    return Promise.resolve(null, item)\n  }\n\n  const callbackName = `callback_${uuid().replace(/-/g, '_')}`\n  const tag = window.document.createElement('script')\n  tag.type = 'text/javascript'\n  tag.async = false\n\n  // Create the promise to return if it is already\n  // resolving\n  const promise = new Promise((resolve, reject) => {\n    const handleResult = state => evt => {\n      const instance = scriptMap.get(key)\n      if (state === LOADED) {\n        instance.loaded = true\n        resolve(evt)\n      } else if (state === ERROR) {\n        instance.error = evt\n        reject(evt)\n      }\n\n      instance.promise = null\n      scriptMap.set(key, instance)\n      cleanup(callbackName)\n    }\n\n    // Add error handlers\n    tag.onerror = handleResult(ERROR)\n    tag.onreadystatechange = () => {\n      handleResult(tag.readyState)\n    }\n\n    // Replace callback if there is one\n    // or just resolve the promise\n    if (script.match(/callback=CALLBACK_PLACEHOLDER/)) {\n      src = src.replace(/(callback=)[^&]+/, `$1${callbackName}`)\n      window[callbackName] = handleResult(LOADED)\n    } else {\n      tag.onload = handleResult(LOADED)\n      tag.addEventListener('load', tag.onload)\n    }\n\n    // Start loading the script\n    tag.src = src\n    window.document.body.appendChild(tag)\n  })\n\n  const initialState = {\n    loaded: false,\n    error: false,\n    promise,\n  }\n\n  scriptMap.set(key, initialState)\n\n  return promise\n}\n\nexport default load\n"]}